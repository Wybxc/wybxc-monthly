# 笔记 | 关于“基本类型”

:::tip
本文首发于知乎。
:::

从底层的角度看，基本类型是必须存在的。因为只有基本类型才能被 CPU 直接识别和处理。CPU 不认识对象和结构，但它永远认识整数和布尔值。所以，一个想要编译到机器码的语言，不管是 AOT 还是 JIT，都必须有基本类型的设计。

题主的疑问大概来自于基本类型和对象类型的割裂，基本类型不像对象一样有自己的方法。为了解决这个问题，Java 搞出来了“装箱”，这其实完全是无奈之举。因为 JVM 设计的时候，类型论和工程实践结合的问题还没有很好地解决，有一些类型论里的思想是没有得到实现的。

所以，**设计失败的不是基本类型，而是基本类型和其他类型的割裂。**

要消除这种割裂感，需要从顶层和底层两个层面入手。

顶层指的就是类型系统。在 Rust 里，所谓基本类型与其他类型的区别其实只有一个：它们实现的是 Copy trait 而非 Move trait。这一点区别很好地概括了基本类型和其他类型的本质不同：比如，安全的复制意味着没有内部结构；所有权可以随意给出意味着对存放的位置没有限制，甚至可以只存在寄存器而不存在内存中……这些需要复杂语言说明的底层上的区别，在类型系统里就是 Copy 与 Move 之分。这就让基本类型融入了类型系统中，而不是在类型系统里给基本类型特殊对待。

在底层，主要需要解决的问题是怎样给基本类型也实现与其他类型一样的“方法调用”。其实很简单，对象方法无非就是多了一个隐式的 self 参数，只要允许 self 是基本类型，就不会有问题。在 Rust 里，你可以为基本类型实现一个 trait，这样就能让基本类型也有方法调用。虽然，这样做的确无法实现继承和多态，但是，Rust 不是一门完全面向对象的语言，在 Rust 的实现里，用组合和简单的动态联编完全可以实现继承多态一样的表现力。

可以看到，Rust 基本已经解决了基本类型和其他类型割裂的问题，这足以证明，在良好的设计下，基本类型并非一个错误。

以上。
